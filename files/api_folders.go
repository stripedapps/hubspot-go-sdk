/*
Files

Upload and manage files.

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// FoldersAPIService FoldersAPI service
type FoldersAPIService service

type ApiDeleteFilesV3FoldersFolderIdArchiveRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	folderId string
}

func (r ApiDeleteFilesV3FoldersFolderIdArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFilesV3FoldersFolderIdArchiveExecute(r)
}

/*
DeleteFilesV3FoldersFolderIdArchive Delete folder by ID

Delete folder by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folderId ID of folder to delete.
 @return ApiDeleteFilesV3FoldersFolderIdArchiveRequest
*/
func (a *FoldersAPIService) DeleteFilesV3FoldersFolderIdArchive(ctx context.Context, folderId string) ApiDeleteFilesV3FoldersFolderIdArchiveRequest {
	return ApiDeleteFilesV3FoldersFolderIdArchiveRequest{
		ApiService: a,
		ctx: ctx,
		folderId: folderId,
	}
}

// Execute executes the request
func (a *FoldersAPIService) DeleteFilesV3FoldersFolderIdArchiveExecute(r ApiDeleteFilesV3FoldersFolderIdArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.DeleteFilesV3FoldersFolderIdArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/folders/{folderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteFilesV3FoldersFolderPathArchiveByPathRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	folderPath string
}

func (r ApiDeleteFilesV3FoldersFolderPathArchiveByPathRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFilesV3FoldersFolderPathArchiveByPathExecute(r)
}

/*
DeleteFilesV3FoldersFolderPathArchiveByPath Delete folder by path

Delete a folder, identified by its path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folderPath Path of folder to delete
 @return ApiDeleteFilesV3FoldersFolderPathArchiveByPathRequest
*/
func (a *FoldersAPIService) DeleteFilesV3FoldersFolderPathArchiveByPath(ctx context.Context, folderPath string) ApiDeleteFilesV3FoldersFolderPathArchiveByPathRequest {
	return ApiDeleteFilesV3FoldersFolderPathArchiveByPathRequest{
		ApiService: a,
		ctx: ctx,
		folderPath: folderPath,
	}
}

// Execute executes the request
func (a *FoldersAPIService) DeleteFilesV3FoldersFolderPathArchiveByPathExecute(r ApiDeleteFilesV3FoldersFolderPathArchiveByPathRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.DeleteFilesV3FoldersFolderPathArchiveByPath")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/folders/{folderPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"folderPath"+"}", url.PathEscape(parameterValueToString(r.folderPath, "folderPath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFilesV3FoldersFolderIdGetByIdRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	folderId string
	properties *[]string
}

// Properties to set on returned folder.
func (r ApiGetFilesV3FoldersFolderIdGetByIdRequest) Properties(properties []string) ApiGetFilesV3FoldersFolderIdGetByIdRequest {
	r.properties = &properties
	return r
}

func (r ApiGetFilesV3FoldersFolderIdGetByIdRequest) Execute() (*Folder, *http.Response, error) {
	return r.ApiService.GetFilesV3FoldersFolderIdGetByIdExecute(r)
}

/*
GetFilesV3FoldersFolderIdGetById Retrieve folder by ID

Retrieve a folder by its ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folderId ID of desired folder
 @return ApiGetFilesV3FoldersFolderIdGetByIdRequest
*/
func (a *FoldersAPIService) GetFilesV3FoldersFolderIdGetById(ctx context.Context, folderId string) ApiGetFilesV3FoldersFolderIdGetByIdRequest {
	return ApiGetFilesV3FoldersFolderIdGetByIdRequest{
		ApiService: a,
		ctx: ctx,
		folderId: folderId,
	}
}

// Execute executes the request
//  @return Folder
func (a *FoldersAPIService) GetFilesV3FoldersFolderIdGetByIdExecute(r ApiGetFilesV3FoldersFolderIdGetByIdRequest) (*Folder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Folder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.GetFilesV3FoldersFolderIdGetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/folders/{folderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilesV3FoldersFolderPathGetByPathRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	folderPath string
	properties *[]string
}

// Properties to set on returned folder.
func (r ApiGetFilesV3FoldersFolderPathGetByPathRequest) Properties(properties []string) ApiGetFilesV3FoldersFolderPathGetByPathRequest {
	r.properties = &properties
	return r
}

func (r ApiGetFilesV3FoldersFolderPathGetByPathRequest) Execute() (*Folder, *http.Response, error) {
	return r.ApiService.GetFilesV3FoldersFolderPathGetByPathExecute(r)
}

/*
GetFilesV3FoldersFolderPathGetByPath Retrieve folder by path

Retrieve a folder, identified by its path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folderPath Path of desired folder.
 @return ApiGetFilesV3FoldersFolderPathGetByPathRequest
*/
func (a *FoldersAPIService) GetFilesV3FoldersFolderPathGetByPath(ctx context.Context, folderPath string) ApiGetFilesV3FoldersFolderPathGetByPathRequest {
	return ApiGetFilesV3FoldersFolderPathGetByPathRequest{
		ApiService: a,
		ctx: ctx,
		folderPath: folderPath,
	}
}

// Execute executes the request
//  @return Folder
func (a *FoldersAPIService) GetFilesV3FoldersFolderPathGetByPathExecute(r ApiGetFilesV3FoldersFolderPathGetByPathRequest) (*Folder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Folder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.GetFilesV3FoldersFolderPathGetByPath")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/folders/{folderPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"folderPath"+"}", url.PathEscape(parameterValueToString(r.folderPath, "folderPath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilesV3FoldersSearchDoSearchRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	properties *[]string
	after *string
	before *string
	limit *int32
	sort *[]string
	ids *[]int64
	idLte *int64
	idGte *int64
	createdAt *time.Time
	createdAtLte *time.Time
	createdAtGte *time.Time
	updatedAt *time.Time
	updatedAtLte *time.Time
	updatedAtGte *time.Time
	name *string
	path *string
	parentFolderIds *[]int64
}

// Properties that should be included in the returned folders.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) Properties(properties []string) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.properties = &properties
	return r
}

// Offset search results by this value. The default offset is 0 and the maximum offset of items for a given search is 10,000. Narrow your search down if you are reaching this limit.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) After(after string) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.after = &after
	return r
}

func (r ApiGetFilesV3FoldersSearchDoSearchRequest) Before(before string) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.before = &before
	return r
}

// Number of items to return. Default limit is 10, maximum limit is 100.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) Limit(limit int32) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.limit = &limit
	return r
}

// Sort results by given property. For example -name sorts by name field descending, name sorts by name field ascending.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) Sort(sort []string) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.sort = &sort
	return r
}

// 
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) Ids(ids []int64) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.ids = &ids
	return r
}

// 
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) IdLte(idLte int64) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.idLte = &idLte
	return r
}

// 
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) IdGte(idGte int64) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.idGte = &idGte
	return r
}

// Search folders by exact time of creation. Time must be epoch time in milliseconds.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) CreatedAt(createdAt time.Time) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.createdAt = &createdAt
	return r
}

// Search folders by less than or equal to time of creation. Can be used with createdAtGte to create a range.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) CreatedAtLte(createdAtLte time.Time) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.createdAtLte = &createdAtLte
	return r
}

// Search folders by greater than or equal to time of creation. Can be used with createdAtLte to create a range.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) CreatedAtGte(createdAtGte time.Time) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.createdAtGte = &createdAtGte
	return r
}

// Search folders by exact time of latest updated. Time must be epoch time in milliseconds.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) UpdatedAt(updatedAt time.Time) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.updatedAt = &updatedAt
	return r
}

// Search folders by less than or equal to time of latest update. Can be used with updatedAtGte to create a range.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) UpdatedAtLte(updatedAtLte time.Time) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.updatedAtLte = &updatedAtLte
	return r
}

// Search folders by greater than or equal to time of latest update. Can be used with updatedAtLte to create a range.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) UpdatedAtGte(updatedAtGte time.Time) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.updatedAtGte = &updatedAtGte
	return r
}

// Search for folders containing the specified name.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) Name(name string) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.name = &name
	return r
}

// Search folders by path.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) Path(path string) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.path = &path
	return r
}

// Search folders with the given parent folderId.
func (r ApiGetFilesV3FoldersSearchDoSearchRequest) ParentFolderIds(parentFolderIds []int64) ApiGetFilesV3FoldersSearchDoSearchRequest {
	r.parentFolderIds = &parentFolderIds
	return r
}

func (r ApiGetFilesV3FoldersSearchDoSearchRequest) Execute() (*CollectionResponseFolder, *http.Response, error) {
	return r.ApiService.GetFilesV3FoldersSearchDoSearchExecute(r)
}

/*
GetFilesV3FoldersSearchDoSearch Search folders

Search for folders. Does not contain hidden or archived folders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFilesV3FoldersSearchDoSearchRequest
*/
func (a *FoldersAPIService) GetFilesV3FoldersSearchDoSearch(ctx context.Context) ApiGetFilesV3FoldersSearchDoSearchRequest {
	return ApiGetFilesV3FoldersSearchDoSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseFolder
func (a *FoldersAPIService) GetFilesV3FoldersSearchDoSearchExecute(r ApiGetFilesV3FoldersSearchDoSearchRequest) (*CollectionResponseFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.GetFilesV3FoldersSearchDoSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/folders/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idLte", r.idLte, "form", "")
	}
	if r.idGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idGte", r.idGte, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAt", r.createdAt, "form", "")
	}
	if r.createdAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAtLte", r.createdAtLte, "form", "")
	}
	if r.createdAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAtGte", r.createdAtGte, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAt", r.updatedAt, "form", "")
	}
	if r.updatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAtLte", r.updatedAtLte, "form", "")
	}
	if r.updatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAtGte", r.updatedAtGte, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.parentFolderIds != nil {
		t := *r.parentFolderIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parentFolderIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parentFolderIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilesV3FoldersUpdateAsyncTasksTaskIdStatusCheckUpdateStatusRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	taskId string
}

func (r ApiGetFilesV3FoldersUpdateAsyncTasksTaskIdStatusCheckUpdateStatusRequest) Execute() (*FolderActionResponse, *http.Response, error) {
	return r.ApiService.GetFilesV3FoldersUpdateAsyncTasksTaskIdStatusCheckUpdateStatusExecute(r)
}

/*
GetFilesV3FoldersUpdateAsyncTasksTaskIdStatusCheckUpdateStatus Check folder update status

Check status of folder update. Folder updates happen asynchronously.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The ID of the folder update task.
 @return ApiGetFilesV3FoldersUpdateAsyncTasksTaskIdStatusCheckUpdateStatusRequest
*/
func (a *FoldersAPIService) GetFilesV3FoldersUpdateAsyncTasksTaskIdStatusCheckUpdateStatus(ctx context.Context, taskId string) ApiGetFilesV3FoldersUpdateAsyncTasksTaskIdStatusCheckUpdateStatusRequest {
	return ApiGetFilesV3FoldersUpdateAsyncTasksTaskIdStatusCheckUpdateStatusRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return FolderActionResponse
func (a *FoldersAPIService) GetFilesV3FoldersUpdateAsyncTasksTaskIdStatusCheckUpdateStatusExecute(r ApiGetFilesV3FoldersUpdateAsyncTasksTaskIdStatusCheckUpdateStatusRequest) (*FolderActionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolderActionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.GetFilesV3FoldersUpdateAsyncTasksTaskIdStatusCheckUpdateStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/folders/update/async/tasks/{taskId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchFilesV3FoldersFolderIdUpdatePropertiesRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	folderId string
	folderUpdateInput *FolderUpdateInput
}

func (r ApiPatchFilesV3FoldersFolderIdUpdatePropertiesRequest) FolderUpdateInput(folderUpdateInput FolderUpdateInput) ApiPatchFilesV3FoldersFolderIdUpdatePropertiesRequest {
	r.folderUpdateInput = &folderUpdateInput
	return r
}

func (r ApiPatchFilesV3FoldersFolderIdUpdatePropertiesRequest) Execute() (*Folder, *http.Response, error) {
	return r.ApiService.PatchFilesV3FoldersFolderIdUpdatePropertiesExecute(r)
}

/*
PatchFilesV3FoldersFolderIdUpdateProperties Update folder properties by folder ID

Update a folder's properties, identified by folder ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folderId ID of folder to update
 @return ApiPatchFilesV3FoldersFolderIdUpdatePropertiesRequest
*/
func (a *FoldersAPIService) PatchFilesV3FoldersFolderIdUpdateProperties(ctx context.Context, folderId string) ApiPatchFilesV3FoldersFolderIdUpdatePropertiesRequest {
	return ApiPatchFilesV3FoldersFolderIdUpdatePropertiesRequest{
		ApiService: a,
		ctx: ctx,
		folderId: folderId,
	}
}

// Execute executes the request
//  @return Folder
func (a *FoldersAPIService) PatchFilesV3FoldersFolderIdUpdatePropertiesExecute(r ApiPatchFilesV3FoldersFolderIdUpdatePropertiesRequest) (*Folder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Folder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.PatchFilesV3FoldersFolderIdUpdateProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/folders/{folderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.folderUpdateInput == nil {
		return localVarReturnValue, nil, reportError("folderUpdateInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.folderUpdateInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFilesV3FoldersCreateRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	folderInput *FolderInput
}

// Folder creation options
func (r ApiPostFilesV3FoldersCreateRequest) FolderInput(folderInput FolderInput) ApiPostFilesV3FoldersCreateRequest {
	r.folderInput = &folderInput
	return r
}

func (r ApiPostFilesV3FoldersCreateRequest) Execute() (*Folder, *http.Response, error) {
	return r.ApiService.PostFilesV3FoldersCreateExecute(r)
}

/*
PostFilesV3FoldersCreate Create folder

Creates a folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFilesV3FoldersCreateRequest
*/
func (a *FoldersAPIService) PostFilesV3FoldersCreate(ctx context.Context) ApiPostFilesV3FoldersCreateRequest {
	return ApiPostFilesV3FoldersCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Folder
func (a *FoldersAPIService) PostFilesV3FoldersCreateExecute(r ApiPostFilesV3FoldersCreateRequest) (*Folder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Folder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.PostFilesV3FoldersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.folderInput == nil {
		return localVarReturnValue, nil, reportError("folderInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.folderInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursivelyRequest struct {
	ctx context.Context
	ApiService *FoldersAPIService
	folderUpdateInputWithId *FolderUpdateInputWithId
}

func (r ApiPostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursivelyRequest) FolderUpdateInputWithId(folderUpdateInputWithId FolderUpdateInputWithId) ApiPostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursivelyRequest {
	r.folderUpdateInputWithId = &folderUpdateInputWithId
	return r
}

func (r ApiPostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursivelyRequest) Execute() (*FolderUpdateTaskLocator, *http.Response, error) {
	return r.ApiService.PostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursivelyExecute(r)
}

/*
PostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursively Update folder properties

Update properties of folder by given ID. This action happens asynchronously and will update all of the folder's children as well.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursivelyRequest
*/
func (a *FoldersAPIService) PostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursively(ctx context.Context) ApiPostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursivelyRequest {
	return ApiPostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursivelyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolderUpdateTaskLocator
func (a *FoldersAPIService) PostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursivelyExecute(r ApiPostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursivelyRequest) (*FolderUpdateTaskLocator, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolderUpdateTaskLocator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FoldersAPIService.PostFilesV3FoldersUpdateAsyncUpdatePropertiesRecursively")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/folders/update/async"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.folderUpdateInputWithId == nil {
		return localVarReturnValue, nil, reportError("folderUpdateInputWithId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.folderUpdateInputWithId
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
