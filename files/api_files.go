/*
Files

Upload and manage files.

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
	"os"
)


// FilesAPIService FilesAPI service
type FilesAPIService service

type ApiDeleteFilesV3FilesFileIdArchiveRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileId string
}

func (r ApiDeleteFilesV3FilesFileIdArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFilesV3FilesFileIdArchiveExecute(r)
}

/*
DeleteFilesV3FilesFileIdArchive Delete file by ID

Delete a file by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId FileId to delete
 @return ApiDeleteFilesV3FilesFileIdArchiveRequest
*/
func (a *FilesAPIService) DeleteFilesV3FilesFileIdArchive(ctx context.Context, fileId string) ApiDeleteFilesV3FilesFileIdArchiveRequest {
	return ApiDeleteFilesV3FilesFileIdArchiveRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

// Execute executes the request
func (a *FilesAPIService) DeleteFilesV3FilesFileIdArchiveExecute(r ApiDeleteFilesV3FilesFileIdArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.DeleteFilesV3FilesFileIdArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/files/{fileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteFilesV3FilesFileIdGdprDeleteDeleteRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileId string
}

func (r ApiDeleteFilesV3FilesFileIdGdprDeleteDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFilesV3FilesFileIdGdprDeleteDeleteExecute(r)
}

/*
DeleteFilesV3FilesFileIdGdprDeleteDelete GDPR-delete file

Delete a file in accordance with GDPR regulations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId ID of file to GDPR delete
 @return ApiDeleteFilesV3FilesFileIdGdprDeleteDeleteRequest
*/
func (a *FilesAPIService) DeleteFilesV3FilesFileIdGdprDeleteDelete(ctx context.Context, fileId string) ApiDeleteFilesV3FilesFileIdGdprDeleteDeleteRequest {
	return ApiDeleteFilesV3FilesFileIdGdprDeleteDeleteRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

// Execute executes the request
func (a *FilesAPIService) DeleteFilesV3FilesFileIdGdprDeleteDeleteExecute(r ApiDeleteFilesV3FilesFileIdGdprDeleteDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.DeleteFilesV3FilesFileIdGdprDeleteDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/files/{fileId}/gdpr-delete"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFilesV3FilesFileIdGetByIdRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileId string
	properties *[]string
}

// null
func (r ApiGetFilesV3FilesFileIdGetByIdRequest) Properties(properties []string) ApiGetFilesV3FilesFileIdGetByIdRequest {
	r.properties = &properties
	return r
}

func (r ApiGetFilesV3FilesFileIdGetByIdRequest) Execute() (*File, *http.Response, error) {
	return r.ApiService.GetFilesV3FilesFileIdGetByIdExecute(r)
}

/*
GetFilesV3FilesFileIdGetById Retrieve file by ID

Retrieve a file by its ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId ID of the desired file.
 @return ApiGetFilesV3FilesFileIdGetByIdRequest
*/
func (a *FilesAPIService) GetFilesV3FilesFileIdGetById(ctx context.Context, fileId string) ApiGetFilesV3FilesFileIdGetByIdRequest {
	return ApiGetFilesV3FilesFileIdGetByIdRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

// Execute executes the request
//  @return File
func (a *FilesAPIService) GetFilesV3FilesFileIdGetByIdExecute(r ApiGetFilesV3FilesFileIdGetByIdRequest) (*File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.GetFilesV3FilesFileIdGetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/files/{fileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileId string
	size *string
	expirationSeconds *int64
	upscale *bool
}

// For image files. This will resize the image to the desired size before sharing. Does not affect the original file, just the file served by this signed URL.
func (r ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest) Size(size string) ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest {
	r.size = &size
	return r
}

// How long in seconds the link will provide access to the file.
func (r ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest) ExpirationSeconds(expirationSeconds int64) ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest {
	r.expirationSeconds = &expirationSeconds
	return r
}

// If size is provided, this will upscale the image to fit the size dimensions.
func (r ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest) Upscale(upscale bool) ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest {
	r.upscale = &upscale
	return r
}

func (r ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest) Execute() (*SignedUrl, *http.Response, error) {
	return r.ApiService.GetFilesV3FilesFileIdSignedUrlGetSignedUrlExecute(r)
}

/*
GetFilesV3FilesFileIdSignedUrlGetSignedUrl Get signed URL to access private file

Generates signed URL that allows temporary access to a private file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId ID of file.
 @return ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest
*/
func (a *FilesAPIService) GetFilesV3FilesFileIdSignedUrlGetSignedUrl(ctx context.Context, fileId string) ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest {
	return ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

// Execute executes the request
//  @return SignedUrl
func (a *FilesAPIService) GetFilesV3FilesFileIdSignedUrlGetSignedUrlExecute(r ApiGetFilesV3FilesFileIdSignedUrlGetSignedUrlRequest) (*SignedUrl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignedUrl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.GetFilesV3FilesFileIdSignedUrlGetSignedUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/files/{fileId}/signed-url"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.expirationSeconds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationSeconds", r.expirationSeconds, "form", "")
	}
	if r.upscale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upscale", r.upscale, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilesV3FilesImportFromUrlAsyncTasksTaskIdStatusCheckImportRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	taskId string
}

func (r ApiGetFilesV3FilesImportFromUrlAsyncTasksTaskIdStatusCheckImportRequest) Execute() (*FileActionResponse, *http.Response, error) {
	return r.ApiService.GetFilesV3FilesImportFromUrlAsyncTasksTaskIdStatusCheckImportExecute(r)
}

/*
GetFilesV3FilesImportFromUrlAsyncTasksTaskIdStatusCheckImport Check import status

Check the status of requested import.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId Import by URL task ID
 @return ApiGetFilesV3FilesImportFromUrlAsyncTasksTaskIdStatusCheckImportRequest
*/
func (a *FilesAPIService) GetFilesV3FilesImportFromUrlAsyncTasksTaskIdStatusCheckImport(ctx context.Context, taskId string) ApiGetFilesV3FilesImportFromUrlAsyncTasksTaskIdStatusCheckImportRequest {
	return ApiGetFilesV3FilesImportFromUrlAsyncTasksTaskIdStatusCheckImportRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return FileActionResponse
func (a *FilesAPIService) GetFilesV3FilesImportFromUrlAsyncTasksTaskIdStatusCheckImportExecute(r ApiGetFilesV3FilesImportFromUrlAsyncTasksTaskIdStatusCheckImportRequest) (*FileActionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileActionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.GetFilesV3FilesImportFromUrlAsyncTasksTaskIdStatusCheckImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/files/import-from-url/async/tasks/{taskId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilesV3FilesSearchDoSearchRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	properties *[]string
	after *string
	before *string
	limit *int32
	sort *[]string
	ids *[]int64
	idLte *int64
	idGte *int64
	createdAt *time.Time
	createdAtLte *time.Time
	createdAtGte *time.Time
	updatedAt *time.Time
	updatedAtLte *time.Time
	updatedAtGte *time.Time
	name *string
	path *string
	parentFolderIds *[]int64
	size *int64
	sizeLte *int64
	sizeGte *int64
	height *int32
	heightLte *int32
	heightGte *int32
	width *int32
	widthLte *int32
	widthGte *int32
	encoding *string
	type_ *string
	extension *string
	url *string
	isUsableInContent *bool
	allowsAnonymousAccess *bool
	fileMd5 *string
	expiresAt *time.Time
	expiresAtLte *time.Time
	expiresAtGte *time.Time
}

// A list of file properties to return.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Properties(properties []string) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.properties = &properties
	return r
}

// Offset search results by this value. The default offset is 0 and the maximum offset of items for a given search is 10,000. Narrow your search down if you are reaching this limit.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) After(after string) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.after = &after
	return r
}

// 
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Before(before string) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.before = &before
	return r
}

// Number of items to return. Default limit is 10, maximum limit is 100.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Limit(limit int32) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.limit = &limit
	return r
}

// Sort files by a given field.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Sort(sort []string) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.sort = &sort
	return r
}

// Search by a list of file IDs.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Ids(ids []int64) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.ids = &ids
	return r
}

// 
func (r ApiGetFilesV3FilesSearchDoSearchRequest) IdLte(idLte int64) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.idLte = &idLte
	return r
}

// 
func (r ApiGetFilesV3FilesSearchDoSearchRequest) IdGte(idGte int64) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.idGte = &idGte
	return r
}

// Search files by time of creation.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) CreatedAt(createdAt time.Time) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.createdAt = &createdAt
	return r
}

// Search files by less than or equal to time of creation. Can be used with &#x60;createdAtGte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) CreatedAtLte(createdAtLte time.Time) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.createdAtLte = &createdAtLte
	return r
}

// Search files by greater than or equal to time of creation. Can be used with &#x60;createdAtLte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) CreatedAtGte(createdAtGte time.Time) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.createdAtGte = &createdAtGte
	return r
}

// Search files by time of latest updated.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) UpdatedAt(updatedAt time.Time) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.updatedAt = &updatedAt
	return r
}

// Search files by less than or equal to time of latest update. Can be used with &#x60;updatedAtGte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) UpdatedAtLte(updatedAtLte time.Time) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.updatedAtLte = &updatedAtLte
	return r
}

// Search files by greater than or equal to time of latest update. Can be used with &#x60;updatedAtLte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) UpdatedAtGte(updatedAtGte time.Time) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.updatedAtGte = &updatedAtGte
	return r
}

// Search for files containing the given name.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Name(name string) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.name = &name
	return r
}

// Search files by path.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Path(path string) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.path = &path
	return r
}

// Search files within given &#x60;folderId&#x60;.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) ParentFolderIds(parentFolderIds []int64) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.parentFolderIds = &parentFolderIds
	return r
}

// Search files by exact file size in bytes.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Size(size int64) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.size = &size
	return r
}

// Search files by less than or equal to file size. Can be used with &#x60;sizeGte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) SizeLte(sizeLte int64) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.sizeLte = &sizeLte
	return r
}

// Search files by greater than or equal to file size. Can be used with &#x60;sizeLte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) SizeGte(sizeGte int64) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.sizeGte = &sizeGte
	return r
}

// Search files by height of image or video.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Height(height int32) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.height = &height
	return r
}

// Search files by less than or equal to height of image or video. Can be used with &#x60;heightGte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) HeightLte(heightLte int32) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.heightLte = &heightLte
	return r
}

// Search files by greater than or equal to height of image or video. Can be used with &#x60;heightLte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) HeightGte(heightGte int32) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.heightGte = &heightGte
	return r
}

// Search files by width of image or video.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Width(width int32) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.width = &width
	return r
}

// Search files by less than or equal to width of image or video. Can be used with &#x60;widthGte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) WidthLte(widthLte int32) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.widthLte = &widthLte
	return r
}

// Search files by greater than or equal to width of image or video. Can be used with &#x60;widthLte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) WidthGte(widthGte int32) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.widthGte = &widthGte
	return r
}

// Search files by specified encoding.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Encoding(encoding string) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.encoding = &encoding
	return r
}

// Filter by provided file type.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Type_(type_ string) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.type_ = &type_
	return r
}

// Search files by given extension.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Extension(extension string) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.extension = &extension
	return r
}

// Search by file URL.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) Url(url string) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.url = &url
	return r
}

// If &#x60;true&#x60;, shows files that have been marked to be used in new content. If &#x60;false&#x60;, shows files that should not be used in new content.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) IsUsableInContent(isUsableInContent bool) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.isUsableInContent = &isUsableInContent
	return r
}

// Search files by access. If &#x60;true&#x60;, will show only public files. If &#x60;false&#x60;, will show only private files.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) AllowsAnonymousAccess(allowsAnonymousAccess bool) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.allowsAnonymousAccess = &allowsAnonymousAccess
	return r
}

// Search files by a specific md5 hash.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) FileMd5(fileMd5 string) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.fileMd5 = &fileMd5
	return r
}

// Search files by exact expires time. Time must be epoch time in milliseconds.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) ExpiresAt(expiresAt time.Time) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.expiresAt = &expiresAt
	return r
}

// Search files by less than or equal to expires time. Can be used with &#x60;expiresAtGte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) ExpiresAtLte(expiresAtLte time.Time) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.expiresAtLte = &expiresAtLte
	return r
}

// Search files by greater than or equal to expires time. Can be used with &#x60;expiresAtLte&#x60; to create a range.
func (r ApiGetFilesV3FilesSearchDoSearchRequest) ExpiresAtGte(expiresAtGte time.Time) ApiGetFilesV3FilesSearchDoSearchRequest {
	r.expiresAtGte = &expiresAtGte
	return r
}

func (r ApiGetFilesV3FilesSearchDoSearchRequest) Execute() (*CollectionResponseFile, *http.Response, error) {
	return r.ApiService.GetFilesV3FilesSearchDoSearchExecute(r)
}

/*
GetFilesV3FilesSearchDoSearch Search files

Search through files in the file manager. Does not display hidden or archived files.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFilesV3FilesSearchDoSearchRequest
*/
func (a *FilesAPIService) GetFilesV3FilesSearchDoSearch(ctx context.Context) ApiGetFilesV3FilesSearchDoSearchRequest {
	return ApiGetFilesV3FilesSearchDoSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseFile
func (a *FilesAPIService) GetFilesV3FilesSearchDoSearchExecute(r ApiGetFilesV3FilesSearchDoSearchRequest) (*CollectionResponseFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.GetFilesV3FilesSearchDoSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/files/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idLte", r.idLte, "form", "")
	}
	if r.idGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idGte", r.idGte, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAt", r.createdAt, "form", "")
	}
	if r.createdAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAtLte", r.createdAtLte, "form", "")
	}
	if r.createdAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAtGte", r.createdAtGte, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAt", r.updatedAt, "form", "")
	}
	if r.updatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAtLte", r.updatedAtLte, "form", "")
	}
	if r.updatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAtGte", r.updatedAtGte, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.parentFolderIds != nil {
		t := *r.parentFolderIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parentFolderIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parentFolderIds", t, "form", "multi")
		}
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.sizeLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sizeLte", r.sizeLte, "form", "")
	}
	if r.sizeGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sizeGte", r.sizeGte, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.heightLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heightLte", r.heightLte, "form", "")
	}
	if r.heightGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "heightGte", r.heightGte, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.widthLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "widthLte", r.widthLte, "form", "")
	}
	if r.widthGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "widthGte", r.widthGte, "form", "")
	}
	if r.encoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encoding", r.encoding, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.extension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extension", r.extension, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	if r.isUsableInContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isUsableInContent", r.isUsableInContent, "form", "")
	}
	if r.allowsAnonymousAccess != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowsAnonymousAccess", r.allowsAnonymousAccess, "form", "")
	}
	if r.fileMd5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fileMd5", r.fileMd5, "form", "")
	}
	if r.expiresAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expiresAt", r.expiresAt, "form", "")
	}
	if r.expiresAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expiresAtLte", r.expiresAtLte, "form", "")
	}
	if r.expiresAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expiresAtGte", r.expiresAtGte, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilesV3FilesStatPathGetMetadataRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	path string
	properties *[]string
}

// Properties to return in the response.
func (r ApiGetFilesV3FilesStatPathGetMetadataRequest) Properties(properties []string) ApiGetFilesV3FilesStatPathGetMetadataRequest {
	r.properties = &properties
	return r
}

func (r ApiGetFilesV3FilesStatPathGetMetadataRequest) Execute() (*FileStat, *http.Response, error) {
	return r.ApiService.GetFilesV3FilesStatPathGetMetadataExecute(r)
}

/*
GetFilesV3FilesStatPathGetMetadata Retrieve file by path

Retrieve a file by its path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param path The path of the file. 
 @return ApiGetFilesV3FilesStatPathGetMetadataRequest
*/
func (a *FilesAPIService) GetFilesV3FilesStatPathGetMetadata(ctx context.Context, path string) ApiGetFilesV3FilesStatPathGetMetadataRequest {
	return ApiGetFilesV3FilesStatPathGetMetadataRequest{
		ApiService: a,
		ctx: ctx,
		path: path,
	}
}

// Execute executes the request
//  @return FileStat
func (a *FilesAPIService) GetFilesV3FilesStatPathGetMetadataExecute(r ApiGetFilesV3FilesStatPathGetMetadataRequest) (*FileStat, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileStat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.GetFilesV3FilesStatPathGetMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/files/stat/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchFilesV3FilesFileIdUpdatePropertiesRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileId string
	fileUpdateInput *FileUpdateInput
}

func (r ApiPatchFilesV3FilesFileIdUpdatePropertiesRequest) FileUpdateInput(fileUpdateInput FileUpdateInput) ApiPatchFilesV3FilesFileIdUpdatePropertiesRequest {
	r.fileUpdateInput = &fileUpdateInput
	return r
}

func (r ApiPatchFilesV3FilesFileIdUpdatePropertiesRequest) Execute() (*File, *http.Response, error) {
	return r.ApiService.PatchFilesV3FilesFileIdUpdatePropertiesExecute(r)
}

/*
PatchFilesV3FilesFileIdUpdateProperties Update file properties

Update properties of file by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId ID of file to update
 @return ApiPatchFilesV3FilesFileIdUpdatePropertiesRequest
*/
func (a *FilesAPIService) PatchFilesV3FilesFileIdUpdateProperties(ctx context.Context, fileId string) ApiPatchFilesV3FilesFileIdUpdatePropertiesRequest {
	return ApiPatchFilesV3FilesFileIdUpdatePropertiesRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

// Execute executes the request
//  @return File
func (a *FilesAPIService) PatchFilesV3FilesFileIdUpdatePropertiesExecute(r ApiPatchFilesV3FilesFileIdUpdatePropertiesRequest) (*File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.PatchFilesV3FilesFileIdUpdateProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/files/{fileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileUpdateInput == nil {
		return localVarReturnValue, nil, reportError("fileUpdateInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileUpdateInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFilesV3FilesImportFromUrlAsyncImportFromUrlRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	importFromUrlInput *ImportFromUrlInput
}

func (r ApiPostFilesV3FilesImportFromUrlAsyncImportFromUrlRequest) ImportFromUrlInput(importFromUrlInput ImportFromUrlInput) ApiPostFilesV3FilesImportFromUrlAsyncImportFromUrlRequest {
	r.importFromUrlInput = &importFromUrlInput
	return r
}

func (r ApiPostFilesV3FilesImportFromUrlAsyncImportFromUrlRequest) Execute() (*ImportFromUrlTaskLocator, *http.Response, error) {
	return r.ApiService.PostFilesV3FilesImportFromUrlAsyncImportFromUrlExecute(r)
}

/*
PostFilesV3FilesImportFromUrlAsyncImportFromUrl Import file from URL

Asynchronously imports the file at the given URL into the file manager.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFilesV3FilesImportFromUrlAsyncImportFromUrlRequest
*/
func (a *FilesAPIService) PostFilesV3FilesImportFromUrlAsyncImportFromUrl(ctx context.Context) ApiPostFilesV3FilesImportFromUrlAsyncImportFromUrlRequest {
	return ApiPostFilesV3FilesImportFromUrlAsyncImportFromUrlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ImportFromUrlTaskLocator
func (a *FilesAPIService) PostFilesV3FilesImportFromUrlAsyncImportFromUrlExecute(r ApiPostFilesV3FilesImportFromUrlAsyncImportFromUrlRequest) (*ImportFromUrlTaskLocator, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImportFromUrlTaskLocator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.PostFilesV3FilesImportFromUrlAsyncImportFromUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/files/import-from-url/async"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.importFromUrlInput == nil {
		return localVarReturnValue, nil, reportError("importFromUrlInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.importFromUrlInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFilesV3FilesUploadRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	file *os.File
	folderId *string
	folderPath *string
	fileName *string
	charsetHunch *string
	options *string
}

// File to be uploaded.
func (r ApiPostFilesV3FilesUploadRequest) File(file *os.File) ApiPostFilesV3FilesUploadRequest {
	r.file = file
	return r
}

// Either &#39;folderId&#39; or &#39;folderPath&#39; is required. folderId is the ID of the folder the file will be uploaded to.
func (r ApiPostFilesV3FilesUploadRequest) FolderId(folderId string) ApiPostFilesV3FilesUploadRequest {
	r.folderId = &folderId
	return r
}

// Either &#39;folderPath&#39; or &#39;folderId&#39; is required. This field represents the destination folder path for the uploaded file. If a path doesn&#39;t exist, the system will try to create one.
func (r ApiPostFilesV3FilesUploadRequest) FolderPath(folderPath string) ApiPostFilesV3FilesUploadRequest {
	r.folderPath = &folderPath
	return r
}

// Desired name for the uploaded file.
func (r ApiPostFilesV3FilesUploadRequest) FileName(fileName string) ApiPostFilesV3FilesUploadRequest {
	r.fileName = &fileName
	return r
}

// Character set of the uploaded file.
func (r ApiPostFilesV3FilesUploadRequest) CharsetHunch(charsetHunch string) ApiPostFilesV3FilesUploadRequest {
	r.charsetHunch = &charsetHunch
	return r
}

// JSON string representing FileUploadOptions.
func (r ApiPostFilesV3FilesUploadRequest) Options(options string) ApiPostFilesV3FilesUploadRequest {
	r.options = &options
	return r
}

func (r ApiPostFilesV3FilesUploadRequest) Execute() (*File, *http.Response, error) {
	return r.ApiService.PostFilesV3FilesUploadExecute(r)
}

/*
PostFilesV3FilesUpload Upload file

Upload a single file with content specified in request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFilesV3FilesUploadRequest
*/
func (a *FilesAPIService) PostFilesV3FilesUpload(ctx context.Context) ApiPostFilesV3FilesUploadRequest {
	return ApiPostFilesV3FilesUploadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return File
func (a *FilesAPIService) PostFilesV3FilesUploadExecute(r ApiPostFilesV3FilesUploadRequest) (*File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.PostFilesV3FilesUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.folderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "folderId", r.folderId, "", "")
	}
	if r.folderPath != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "folderPath", r.folderPath, "", "")
	}
	if r.fileName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fileName", r.fileName, "", "")
	}
	if r.charsetHunch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "charsetHunch", r.charsetHunch, "", "")
	}
	if r.options != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "options", r.options, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFilesV3FilesFileIdReplaceRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileId string
	file *os.File
	charsetHunch *string
	options *string
}

// File data that will replace existing file in the file manager.
func (r ApiPutFilesV3FilesFileIdReplaceRequest) File(file *os.File) ApiPutFilesV3FilesFileIdReplaceRequest {
	r.file = file
	return r
}

// Character set of given file data.
func (r ApiPutFilesV3FilesFileIdReplaceRequest) CharsetHunch(charsetHunch string) ApiPutFilesV3FilesFileIdReplaceRequest {
	r.charsetHunch = &charsetHunch
	return r
}

// JSON string representing FileReplaceOptions. Includes options to set the access and expiresAt properties, which will automatically update when the file is replaced.
func (r ApiPutFilesV3FilesFileIdReplaceRequest) Options(options string) ApiPutFilesV3FilesFileIdReplaceRequest {
	r.options = &options
	return r
}

func (r ApiPutFilesV3FilesFileIdReplaceRequest) Execute() (*File, *http.Response, error) {
	return r.ApiService.PutFilesV3FilesFileIdReplaceExecute(r)
}

/*
PutFilesV3FilesFileIdReplace Replace file

Replace existing file data with new file data. Can be used to change image content without having to upload a new file and update all references.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId ID of the desired file.
 @return ApiPutFilesV3FilesFileIdReplaceRequest
*/
func (a *FilesAPIService) PutFilesV3FilesFileIdReplace(ctx context.Context, fileId string) ApiPutFilesV3FilesFileIdReplaceRequest {
	return ApiPutFilesV3FilesFileIdReplaceRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

// Execute executes the request
//  @return File
func (a *FilesAPIService) PutFilesV3FilesFileIdReplaceExecute(r ApiPutFilesV3FilesFileIdReplaceRequest) (*File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.PutFilesV3FilesFileIdReplace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/files/v3/files/{fileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.charsetHunch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "charsetHunch", r.charsetHunch, "", "")
	}
	if r.options != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "options", r.options, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
