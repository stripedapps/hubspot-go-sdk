/*
Schemas

The CRM uses schemas to define how custom objects should store and represent information in the HubSpot CRM. Schemas define details about an object's type, properties, and associations. The schema can be uniquely identified by its **object type ID**.

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the PropertyModificationMetadata type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &PropertyModificationMetadata{}

// PropertyModificationMetadata struct for PropertyModificationMetadata
type PropertyModificationMetadata struct {
	// 
	ReadOnlyOptions *bool `json:"readOnlyOptions,omitempty"`
	// 
	ReadOnlyValue bool `json:"readOnlyValue"`
	// 
	ReadOnlyDefinition bool `json:"readOnlyDefinition"`
	// 
	Archivable bool `json:"archivable"`
}

type _PropertyModificationMetadata PropertyModificationMetadata

// NewPropertyModificationMetadata instantiates a new PropertyModificationMetadata object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewPropertyModificationMetadata(readOnlyValue bool, readOnlyDefinition bool, archivable bool) *PropertyModificationMetadata {
	this := PropertyModificationMetadata{}
	this.ReadOnlyValue = readOnlyValue
	this.ReadOnlyDefinition = readOnlyDefinition
	this.Archivable = archivable
	return &this
}

// NewPropertyModificationMetadataWithDefaults instantiates a new PropertyModificationMetadata object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewPropertyModificationMetadataWithDefaults() *PropertyModificationMetadata {
	this := PropertyModificationMetadata{}
	return &this
}

// GetReadOnlyOptions returns the ReadOnlyOptions field value if set, zero value otherwise.
func (o *PropertyModificationMetadata) GetReadOnlyOptions() bool {
	if o == nil || IsNil(o.ReadOnlyOptions) {
		var ret bool
		return ret
	}
	return *o.ReadOnlyOptions
}

// GetReadOnlyOptionsOk returns a tuple with the ReadOnlyOptions field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *PropertyModificationMetadata) GetReadOnlyOptionsOk() (*bool, bool) {
	if o == nil || IsNil(o.ReadOnlyOptions) {
		return nil, false
	}
	return o.ReadOnlyOptions, true
}

// HasReadOnlyOptions returns a boolean if a field has been set.
func (o *PropertyModificationMetadata) HasReadOnlyOptions() bool {
	if o != nil && !IsNil(o.ReadOnlyOptions) {
		return true
	}

	return false
}

// SetReadOnlyOptions gets a reference to the given bool and assigns it to the ReadOnlyOptions field.
func (o *PropertyModificationMetadata) SetReadOnlyOptions(v bool) {
	o.ReadOnlyOptions = &v
}

// GetReadOnlyValue returns the ReadOnlyValue field value
func (o *PropertyModificationMetadata) GetReadOnlyValue() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.ReadOnlyValue
}

// GetReadOnlyValueOk returns a tuple with the ReadOnlyValue field value
// and a boolean to check if the value has been set.
func (o *PropertyModificationMetadata) GetReadOnlyValueOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ReadOnlyValue, true
}

// SetReadOnlyValue sets field value
func (o *PropertyModificationMetadata) SetReadOnlyValue(v bool) {
	o.ReadOnlyValue = v
}

// GetReadOnlyDefinition returns the ReadOnlyDefinition field value
func (o *PropertyModificationMetadata) GetReadOnlyDefinition() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.ReadOnlyDefinition
}

// GetReadOnlyDefinitionOk returns a tuple with the ReadOnlyDefinition field value
// and a boolean to check if the value has been set.
func (o *PropertyModificationMetadata) GetReadOnlyDefinitionOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ReadOnlyDefinition, true
}

// SetReadOnlyDefinition sets field value
func (o *PropertyModificationMetadata) SetReadOnlyDefinition(v bool) {
	o.ReadOnlyDefinition = v
}

// GetArchivable returns the Archivable field value
func (o *PropertyModificationMetadata) GetArchivable() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.Archivable
}

// GetArchivableOk returns a tuple with the Archivable field value
// and a boolean to check if the value has been set.
func (o *PropertyModificationMetadata) GetArchivableOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Archivable, true
}

// SetArchivable sets field value
func (o *PropertyModificationMetadata) SetArchivable(v bool) {
	o.Archivable = v
}

func (o PropertyModificationMetadata) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o PropertyModificationMetadata) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.ReadOnlyOptions) {
		toSerialize["readOnlyOptions"] = o.ReadOnlyOptions
	}
	toSerialize["readOnlyValue"] = o.ReadOnlyValue
	toSerialize["readOnlyDefinition"] = o.ReadOnlyDefinition
	toSerialize["archivable"] = o.Archivable
	return toSerialize, nil
}

func (o *PropertyModificationMetadata) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"readOnlyValue",
		"readOnlyDefinition",
		"archivable",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varPropertyModificationMetadata := _PropertyModificationMetadata{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varPropertyModificationMetadata)

	if err != nil {
		return err
	}

	*o = PropertyModificationMetadata(varPropertyModificationMetadata)

	return err
}

type NullablePropertyModificationMetadata struct {
	value *PropertyModificationMetadata
	isSet bool
}

func (v NullablePropertyModificationMetadata) Get() *PropertyModificationMetadata {
	return v.value
}

func (v *NullablePropertyModificationMetadata) Set(val *PropertyModificationMetadata) {
	v.value = val
	v.isSet = true
}

func (v NullablePropertyModificationMetadata) IsSet() bool {
	return v.isSet
}

func (v *NullablePropertyModificationMetadata) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePropertyModificationMetadata(val *PropertyModificationMetadata) *NullablePropertyModificationMetadata {
	return &NullablePropertyModificationMetadata{value: val, isSet: true}
}

func (v NullablePropertyModificationMetadata) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePropertyModificationMetadata) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


